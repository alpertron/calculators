baseconv
LITERAL_DIGITS "($1d dígitos)"

batch
LITERAL_ERROR_IN_EXPRESSION "Error en la expresión $1d: $2s"
LITERAL_MISSING_VARIABLE1 "falta variable x en la primera expresión"
LITERAL_MISSING_VARIABLE2 "falta variable x en la segunda expresión"
LITERAL_MISSING_SEMICOLON1 "se esperaban tres o cuatro puntos y comas pero no hay ninguno"
LITERAL_MISSING_SEMICOLON2 "se esperaban tres o cuatro puntos y comas pero solo hay uno"
LITERAL_MISSING_EQUAL_SIGN1 "falta signo igual en la primera expresión"
LITERAL_MISSING_EQUAL_SIGN2 "falta signo igual en la segunda expresión"
LITERAL_THIRD_SEMICOLON_NOT_FOUND "se esperaban tres o cuatro puntos y comas pero solo hay dos"
LITERAL_MISSING_CLOSING_QUOTE "falta comilla de cierre"
LITERAL_TOO_MANY_CONVERSION_CLAUSES "demasiadas cláusulas de conversión"
LITERAL_STRANGE_CHARACTER_AFTER_PERCENT_SIGN "carácter extraño después de %"
LITERAL_MORE_CONVERSION_CLAUSES_THAN_COLONS "la cantidad de clásulas de conversión es mayor que la cantidad de dos puntos"
LITERAL_LESS_CONVERSION_CLAUSES_THAN_COLONS "la cantidad de clásulas de conversión es menor que la cantidad de dos puntos"
LITERAL_YES "sí"
LITERAL_NO "no"
LITERAL_UNEXPECTED_VARIABLE "Variable inesperada en la expresión."
LITERAL_NO_VALUES "No hay valores para la expresión ingresada."

bignbr
LITERAL_STEP1_BPSW "<p>Paso 1 del algoritmo BPSW de primos probables: Miller-Rabin fuerte con base 2.</p>"
LITERAL_STEP2_BPSW "<p>Paso 2 del algoritmo BPSW de primos probables: Lucas fuerte con P=1, D=$1d, Q=$2d</p>"

contfrac
LITERAL_START_PERIODIC_PART "inicio del período"
LITERAL_PERIODIC_PART_IN_BOLD "donde la parte periódica está señalada en negrita"
LITERAL_COEFFICIENTS_IN_PERIOD " (el período tiene $1d coeficientes)"
LITERAL_TRUNCATED_PERIOD "donde la parte periódica (truncada a partir de los $1d coeficientes) está señalada en negrita."
LITERAL_SHOW_FORMULA_NUM "la fracción cuyo numerador es"
LITERAL_SHOW_FORMULA_DEN "y el denominador es "
LITERAL_EXPANSION_CONTFRAC "El desarrollo en fracción continua de"
LITERAL_ZERO_DENOMINATOR "Error: El denominador es cero."
LITERAL_NUMBER_NOT_REAL "El número no es real, por lo que no tiene desarrollo en fracciones continuas."
LITERAL_NUMERATOR "Numerador"
LITERAL_ARGUMENT_SQROOT "Argumento de la raíz cuadrada"
LITERAL_DENOMINATOR "Denominador"

cubiceq
LITERAL_FROM1 "<p>De $1q:</p>"
LITERAL_FROM2 "<p>De $1q y $2q:</p>"
LITERAL_REPLACING1 "Sustituyendo $1q en $2q:"
LITERAL_CASUSIRR1 "El discriminante es positivo, lo que indica que las tres raíces son reales. En este caso no es posible representar las raíces mediante expresiones radicales de números reales, por lo que se debe utilizar trigonometría."
LITERAL_CASUSIRR7 "Comenzando con la fórmula de la triplicación del ángulo:</p>"
LITERAL_CASUSIRR8 "Sea $1v = $2v "
LITERAL_CASUSIRR2 "El criterio a seguir consiste en igualar los términos de $1q y $2q de izquierda a derecha. Dividiendo por "
LITERAL_CASUSIRR3 "El segundo coeficiente debe valer &minus;3, así que:"
LITERAL_CASUSIRR4 "Igualando el último término:"
LITERAL_CASUSIRR5 "Las soluciones son la raíz cúbica real de "
LITERAL_CASUSIRR6 " y su producto por las dos raíces cúbicas no reales de 1, que son:"
LITERAL_CARDANO1 "Usando el método de Cardano, asignando "
LITERAL_CARDANO2 "Como hay una variable adicional, se puede imponer una condición extra. En este caso la elección es:"
LITERAL_CARDANO3 "Multiplicando por $1p:"
LITERAL_CARDANO4 "Esta es una ecuación cuadrática en $1p. Al multiplicar ($2d) por $3p en vez de $1p, los coeficientes de la ecuación serían los mismos, así que la ecuación cuadrática también permite obtener $3p. Sea $4v = $1p o $3p."
LITERAL_COEFF_NO_ZERO1 "El discriminante es negativo, lo que indica que hay una raíz real y dos raíces complejas conjugadas."
LITERAL_COEFF_NO_ZERO2 "Una raíz cúbica tiene tres soluciones en el campo complejo. Sin embargo, no se puede elegir cualquier valor para $1v y $2v porque se debe cumplir la condición ($3d). Así que el producto debe ser un número real."
LITERAL_COEFF_NO_ZERO3 "Sea"
LITERAL_COEFF_NO_ZERO4 "donde"
LITERAL_COEFF_NO_ZERO5 "son las raíces cúbicas no reales de 1. Como $1v$2s$3v es real, pero $4p y $5p no lo son, los valores de $6v que cumplen la condición ($7d) son:"
LITERAL_SOLVE_CUBIC1 "Dividiendo la ecuación por el coeficiente cúbico:"
LITERAL_SOLVE_CUBIC2 "Para eliminar el término cuadrático se debe hacer la sustitución:"
LITERAL_SOLVE_CUBIC3 "El valor indicado en la sustitución es la tercera parte del coeficiente cuadrático."
LITERAL_SOLVE_CUBIC4 "Distribuyendo:"
LITERAL_SOLVE_CUBIC5 "Simplificando:"
LITERAL_SOLVE_CUBIC6 "La naturaleza de las raíces está dada por el valor del discriminante."
LITERAL_SOLVE_CUBIC7 "donde $1v es el coeficiente lineal y $2v es el término independiente."

dilog
LITERAL_NO_DISCRETE_LOG "No existe el logaritmo discreto"
LITERAL_BASE_POSITIVE "La base debe ser mayor que cero"
LITERAL_POWER_POSITIVE "La potencia debe ser mayor que cero"
LITERAL_MODULUS_GREATER_THAN1 "El módulo debe ser mayor que 1"
LITERAL_COMPUTE_DISCR_SUBGROUP1 "Calculando el logaritmo discreto en subgrupo de $1b$2e elementos"
LITERAL_COMPUTE_DISCR_SUBGROUP2 " módulo $1b"
LITERAL_DISCR_LOG1 "Calculando el logaritmo discreto..."
LITERAL_DISCR_LOG2 "Hallar <var>exp</var> tal que $1b<sup><var>exp</var></sup> &equiv; $2b (mod $3b)"
LITERAL_DISCR_LOG3 "Ningún valor de <var>exp</var> satisface la congruencia."

ecm
LITERAL_ECM1 "Nivel de $1d dígitos:"
LITERAL_ECM2 "Curva $1d usando límites B1=$2d y B2=$3l"

ecmfront
LITERAL_ECM_BATCH_CBACK1 " es primo"
LITERAL_ECM_BATCH_CBACK2 " no es primo"
LITERAL_NBR_DIVISORS "Cantidad de divisores: $1b"
LITERAL_SUM_DIVISORS "Suma de divisores: $1b"
LITERAL_PHI_EULER "Phi de Euler: $1b"
LITERAL_MOBIUS "Möbius: $1d"
LITERAL_ECMFRONT1 "Hallando suma de cuadrados."
LITERAL_ECMFRONT2 "Mostrar divisores"
LITERAL_ECMFRONT3 "Multiplicaciones modulares:"
LITERAL_ECMFRONT4 "ECM: $1l"
LITERAL_ECMFRONT5 "Verificación de números primos probables: $1l"
LITERAL_ECMFRONT6 "SIQS: $1l"
LITERAL_ECMFRONT7 "Suma de cuadrados: $1l"
LITERAL_ECMFRONT8 "SIQS:"
LITERAL_ECMFRONT9 "$1d polinomios utilizados"
LITERAL_ECMFRONT10 "$1d conjuntos de divisiones de prueba"
LITERAL_ECMFRONT11 "$1d congruencias completas (1 de cada $2d valores)"
LITERAL_ECMFRONT12 "$1d congruencias parciales (1 de cada $2d valores)"
LITERAL_ECMFRONT13 "$1d congruencias parciales útiles"
LITERAL_ECMFRONT14 "Tamaño de la matriz binaria: $1d &times; $2d"
LITERAL_ECMFRONT15 "Tiempos:"
LITERAL_ECMFRONT16 "Test de primo probable de $1d $1?1?número??$1?2+?números??: "
LITERAL_ECMFRONT17 "Factorización de $1d $1?1?número??$1?2+?números?? mediante ECM: "
LITERAL_ECMFRONT18 "Factorización de $1d $1?1?número??$1?2+?números?? mediante SIQS: "
LITERAL_SHOW_DIVISORS1 "Lista de divisores:"
LITERAL_SHOW_DIVISORS2 "Cualquier número natural"
LITERAL_SHOW_DIVISORS3 " (primo)"
LITERAL_SHOW_DIVISORS4 "Mostrar más divisores"

errors
LITERAL_TEXT_ERROR1 "Número muy pequeño"
LITERAL_TEXT_ERROR2 "Número muy grande (más de 100000 dígitos)"
LITERAL_TEXT_ERROR3 "Número intermedio muy grande (más de 200000 dígitos)"
LITERAL_TEXT_ERROR4 "División por cero"
LITERAL_TEXT_ERROR5 "Error de paréntesis"
LITERAL_TEXT_ERROR6 "Solo se aceptan números enteros"
LITERAL_TEXT_ERROR7 "Error interno"
LITERAL_TEXT_ERROR8 "Error de sintaxis$1?1+? en la expresión $1d??"
LITERAL_TEXT_ERROR9 "Parámetro inválido"
LITERAL_TEXT_ERROR10 "Muy pocos argumentos"
LITERAL_TEXT_ERROR11 "Demasiados argumentos"
LITERAL_TEXT_ERROR12 "MCD de los argumentos no es 1"
LITERAL_TEXT_ERROR13 "$1?1+?La expresión $1d?? debe incluir la variable $2v y/o el contador $3v"
LITERAL_TEXT_ERROR14 "La expresión no debe incluir variables"
LITERAL_TEXT_ERROR15 "Error interno: no se puede analizar la expresión"

factor
LITERAL_CUNNINGHAM1 "Obteniendo los factores primitivos conocidos del servidor Web."
LITERAL_PROCESS_EXP1 "Transcurrió:"
LITERAL_PROCESS_EXP2 "&nbsp;&nbsp;&nbsp;Exponente potencia +/- 1: $1d"
LITERAL_SHOW_FACTORED_PART1 "Comprobando si $1b es primo "
LITERAL_SHOW_FACTORED_PART2 "Factorizando $1b"
LITERAL_OUTPUT_FACTORIZATION1 " es primo"
LITERAL_OUTPUT_FACTORIZATION2 "Aurifeuille"
LITERAL_OUTPUT_FACTORIZATION3 "Tabla"
LITERAL_OUTPUT_FACTORIZATION4 " - Compuesto"
LITERAL_OUTPUT_FACTORIZATION5 "Criba cuadrática autoinicializada"
LITERAL_OUTPUT_FACTORIZATION6 "Lehman"
LITERAL_OUTPUT_FACTORIZATION7 "Miller y Rabin"
LITERAL_OUTPUT_FACTORIZATION8 "División"
LITERAL_OUTPUT_FACTORIZATION9 "Algebraico"
LITERAL_OUTPUT_FACTORIZATION10 "Método de curvas elípticas"
LITERAL_OUTPUT_FACTORIZATION11 "ECM"
LITERAL_OUTPUT_FACTORIZATION12 "$1s, curva $2d"
LITERAL_OUTPUT_FACTORIZATION13 "SIQS"
LITERAL_OUTPUT_FACTORIZATION14 "Compuesto"
LITERAL_OUTPUT_FACTORIZATION15 " (Desconocido)"
LITERAL_SHOW_ECM_STATUS1 "Paso 1: $1d%"
LITERAL_SHOW_ECM_STATUS2 "Paso 2: $1d%"
LITERAL_SHOW_ECM_STATUS3 "Progreso: $1d%"
LITERAL_PERFORM_TRIAL_DIV1 "División por primos menores que 100000."
LITERAL_FACTOREXT1 "Verificando si el número es una potencia perfecta más o menos 1."
LITERAL_FACTOREXT2 "Verificando si el número es potencia perfecta."

fcubes
LITERAL_FCUBES_BATCH_CBACK1 "La calculadora no funciona si el número es congruente a 4 o 5 (mód 9)"
LITERAL_FCUBES_BATCH_CBACK2 "El usuario detuvo el cálculo"
LITERAL_FCUBES1 "Usando la fórmula"
LITERAL_FCUBES2 "Usando el método de Demjanenko:"
LITERAL_FCUBES3 "Transcurrió:"

fromBlockly
LITERAL_SHOW_BLOCKLY_ERROR1 "Demasiadas variables definidas"
LITERAL_SHOW_BLOCKLY_ERROR2 "El nombre de la variable es muy largo"
LITERAL_SHOW_BLOCKLY_ERROR3 "Debe haber un solo conjunto de bloques unidos"
LITERAL_SHOW_BLOCKLY_ERROR4 "Tipo de bloque inválido"
LITERAL_SHOW_BLOCKLY_ERROR5 "Nombre inválido para el tag shadow en XML"
LITERAL_SHOW_BLOCKLY_ERROR6 "Demasiados tags /block"
LITERAL_SHOW_BLOCKLY_ERROR7 "El bloque suelto debe estar dentro de otro bloque"
LITERAL_SHOW_BLOCKLY_ERROR8 "Error interno: no se puede analizar el XML generado por Blockly"
LITERAL_FROM_BLOCKLY1 "Error interno"
LITERAL_FROM_BLOCKLY2 "No hay nada para mostrar"

fsquares
LITERAL_BATCH_FSQUARES_CBACK1 "¡Error interno!"
LITERAL_BATCH_FSQUARES_CBACK2 "Por favor envíe este número al autor de la calculadora."
LITERAL_BATCH_FSQUARES_CBACK3 ": El usuario detuvo el cálculo"

gaussian
LITERAL_GAUSSIAN1 "Factores de "
LITERAL_GAUSSIAN2 "El valor es "

intpolfact
LITERAL_INTEGRAL_LLL1 "Calculando LLL número $1d en una matriz de $2d &times; $2d."
LITERAL_VAN_HOEIJ1 "Obteniendo factores de dos factores modulares: prueba $1d de $2d"
LITERAL_VAN_HOEIJ2 "Paso 7"
LITERAL_VAN_HOEIJ3 "Paso 8"
LITERAL_VAN_HOEIJ4 "Verificando si los polinomios hallados son factores irreducibles."

lineareq
LITERAL_LINEAREQ "Dividiendo la ecuación por el coeficiente lineal:"

modpolfact
LITERAL_GCD "mcd"
LITERAL_RESTART_RECURSION1 "$1s es una potencia perfecta de grado $2d. Ejecutando el algoritmo nuevamente con:"
LITERAL_SQUAREFREE_FACT1 "Separación de factores con factores repetidos"
LITERAL_SQUAREFREE_FACT2 "La derivada de f(x) es:"
LITERAL_SQUAREFREE_FACT3 " es un factor de f(x) con multiplicidad $1d"
LITERAL_DISTINCT_DEGREE_FACT1 "Factorización de distintos grados"
LITERAL_DISTINCT_DEGREE_FACT2 "Factorizando"
LITERAL_DISTINCT_DEGREE_FACT3 "Para todos los grados $1v entre $2d y $3d, el producto de todos los factores de grado $1v se obtiene calculando "
LITERAL_DISTINCT_DEGREE_FACT4 "Factorización de distintos grados módulo $1b: buscando factores de grado $2d (máx. $3d) del factor número $4d de $5d."
LITERAL_DISTINCT_DEGREE_FACT5 "Este polinomio tiene $1d $1?1?factor irreducible??$1?2+?factores irreducibles?? de grado $2d."
LITERAL_DISTINCT_DEGREE_FACT6 "El nuevo valor de $1v(x) es el cociente entre $1v(x) y el mcd anterior."
LITERAL_DISTINCT_DEGREE_FACT7 "Este polinomio es irreducible."
LITERAL_DISTINCT_DEGREE_FACT8 "$1d% del #$2d.º intento."
LITERAL_EQUAL_DEGREE_FACT1 "Factorizando en polinomios de grado $1d"
LITERAL_EQUAL_DEGREE_FACT2 "Eligiendo $1v(x) al azar, siendo "
LITERAL_EQUAL_DEGREE_FACT3 "calcular mcd($1v, $2v) hasta que el mcd no sea igual a uno de sus argumentos."
LITERAL_EQUAL_DEGREE_FACT4 "mcd($1v, $2v)"
LITERAL_EQUAL_DEGREE_FACT5 "Factorización del mismo grado"
LITERAL_EQUAL_DEGREE_FACT6 "Factorización del mismo grado: buscando $1d factores de grado $2d."
LITERAL_EQUAL_DEGREE_FACT7 "Dividiendo el polinomio por el coeficiente principal:"
LITERAL_FACTOR_MODULAR_POLY "Lista de factores"

output
LITERAL_SHOW_EQ_NBRS "($1d) y ($2d)"
LITERAL_COPYRIGHT "Hecho por Darío Alpern. Actualizado el 1 de diciembre de 2025."

polfact
LITERAL_POLYFACT1 "Polinomio ingresado"
LITERAL_POLYFACT2 "Fracción de polinomios"
LITERAL_POLYFACT3 "Factores irreducibles del polinomio numerador"
LITERAL_POLYFACT4 "Factores irreducibles del polinomio"
LITERAL_POLYFACT5 "El polinomio es irreducible"
LITERAL_POLYFACT6 " debido al criterio de Eisenstein (primo = $1d)"
LITERAL_POLYFACT7 "Los $1d factores son:"
LITERAL_POLYFACT8 "Raíces"
LITERAL_POLYFACT9 "Las $1d raíces son:"

polynomial
LITERAL_HENSEL_LIFTING1 "Lema de Hensel"
LITERAL_HENSEL_LIFTING2 "Aplicando lema de Hensel usando el número primo $1d procesando exponente $2d de $3d."
LITERAL_HENSEL_LIFTING3 "Usando el algoritmo de MCD extendido, calcular "
LITERAL_HENSEL_LIFTING4 " tales que"
LITERAL_ERROR_POL1 "Cannot use variable in exponent"
LITERAL_ERROR_POL2 "La división de polinomios no es entera"
LITERAL_ERROR_POL3 "El denominador debe ser constante"
LITERAL_ERROR_POL4 "El grado del polinomio es muy elevado"
LITERAL_ERROR_POL5 "Exponente muy grande"
LITERAL_ERROR_POL6 "Exponente negativo"
LITERAL_ERROR_POL7 "El primer coeficiente es múltiplo del número primo"
LITERAL_ERROR_POL8 "No se puede elevar porque hay factores duplicados"
LITERAL_ERROR_POL9 "El módulo debe ser mayor que 1"
LITERAL_ERROR_POL10 "El módulo debe ser un número primo o una potencia de número primo"
LITERAL_ERROR_POL11 "No se aceptan múltiples variables"
LITERAL_ERROR_POL12 "No se acepta más de un signo igual"
LITERAL_ERROR_POL13 "Hay un signo igual dentro de paréntesis"

quad
LITERAL_SHOW_ALSO "y también:"
LITERAL_PRINT_LINEAR "x, y: cualquier entero"
LITERAL_NO_SOLS_MOD_PRIME1 "No hay soluciones módulo "
LITERAL_NO_SOLS_MOD_PRIME2 ", así que la ecuación modular no tiene soluciones."
LITERAL_SOLS_MOD_PRIME1 "Soluciones módulo "
LITERAL_SOLS_MOD_PRIME2 " y "
LITERAL_SOLVE_QUADMOD1 "Para resolver esta ecuación cuadrática modular debemos factorizar el módulo y hallar las soluciones módulo las potencias de los factores primos. Luego debemos combinar estas soluciones usando el teorema chino del resto."
LITERAL_LINEAREQ1 "Esta es una ecuación lineal "
LITERAL_LINEAREQ2 "Para resolverla, debemos hallar el máximo común divisor de los coeficientes lineales, esto es: mcd($1b, $2b) = $3b."
LITERAL_LINEAREQ3 "Ahora debemos aplicar el algoritmo generalizado de Euclides:"
LITERAL_LINEAREQ4 "Paso $1d: "
LITERAL_LINEAREQ5 "Multiplicando la última ecuación por "
LITERAL_LINEAREQ6 " obtenemos:"
LITERAL_LINEAREQ7 "Sumando y restando "
LITERAL_LINEAREQ8 "Así, la solución está dada por el conjunto:"
LITERAL_LINEAREQ9 "Es posible reducir los términos independientes."
LITERAL_LINEAREQ10 "Sustituyendo t = t' + K:"
LITERAL_LINEAREQ11 "Debemos hallar el valor de K que minimice la suma de cuadrados de los términos independientes:"
LITERAL_LINEAREQ12 "Para hallar el mínimo, la derivada de f(K) debe ser cero."
LITERAL_LINEAREQ13 "Sustituyendo "
LITERAL_LINEAREQ14 "finalmente obtenemos:"
LITERAL_LINEAREQ15 "Dividiendo la ecuación por el máximo común divisor obtenemos:"
LITERAL_DISCR_ZERO1 "Multiplicando por 4&#8290;$1v"
LITERAL_DISCR_ZERO2 "Sea"
LITERAL_DISCR_ZERO3 "donde el coeficiente lineal es "
LITERAL_DISCR_ZERO4 " y el término independiente es "
LITERAL_DISCR_ZERO5 "Un cuadrado no puede ser igual a un número negativo, así que no hay soluciones."
LITERAL_DISCR_ZERO6 "El término derecho no es cuadrado perfecto, así que no hay soluciones."
LITERAL_DISCR_ZERO7 "La ecuación representa dos rectas paralelas. La primera recta es: "
LITERAL_DISCR_ZERO8 "La segunda recta es:"
LITERAL_DISCR_ZERO9 "Tenemos que resolver"
LITERAL_DISCR_ZERO10 " (donde $1v puede ser cualquier entero)."
LITERAL_CBACK_PARABOLIC1 "Reemplazando $1v en la ecuación $2q y despejando $3s:"
LITERAL_CBACK_PARABOLIC2 "De $1q y $2q:"
LITERAL_CBACK_PARABOLIC3 "Usando $1q para sustituir $2s:"
LITERAL_CBACK_PARABOLIC4 "El coeficiente independiente $1b no es múltiplo de $2b, que es el máximo común divisor de los otros tres coeficientes, por lo que no hay solución."
LITERAL_SHOW_POINT1 "Dividiendo estos números por $1v = $2b:"
LITERAL_SHOW_POINT2 "Estos números no son múltiplos de $1v = $2b."
LITERAL_NON_SQUARE_DISC1 "El algoritmo requiere que el coeficiente de $1v&sup2; y el término independiente sean primos entre sí. Como esto no ocurre, debemos hallar un valor de $2v tal que aplicando una de las transformaciones unimodulares siguientes"
LITERAL_NON_SQUARE_DISC2 "el coeficiente de $1v&sup2; y el término independiente sean primos entre sí. Este coeficiente es igual a "
LITERAL_NON_SQUARE_DISC3 " en el primer caso y "
LITERAL_NON_SQUARE_DISC4 " en el segundo caso."
LITERAL_NON_SQUARE_DISC5 "Usaremos la primera transformación unimodular con $1v = $2d:"
LITERAL_NON_SQUARE_DISC6 "Usaremos la segunda transformación unimodular con $1v = $2d:"
LITERAL_NON_SQUARE_DISC7 "mediante $1q, la ecuación $2q se convierte a:"
LITERAL_NON_SQUARE_DISC8 "A continuación hay que resolver varias ecuaciones cuadráticas modulares. Para ello debemos factorizar el módulo y hallar las soluciones módulo las potencias de los factores primos. Luego debemos combinar estas soluciones usando el teorema chino del resto."
LITERAL_NON_SQUARE_DISC9 "Los diferentes módulos son divisores del término independiente, por lo que basta con factorizar dicho valor."
LITERAL_NON_SQUARE_DISC10 "Sea $1b&#8290;$2s = $3s y $1b&#8290;$4s = $5s. "
LITERAL_NON_SQUARE_DISC11 "Buscando soluciones $1s e $2s primos entre sí."
LITERAL_NON_SQUARE_DISC12 "De la ecuación $1q obtenemos "
LITERAL_NON_SQUARE_DISC13 "Debemos resolver: "
LITERAL_SHOW_BEFORE_UNIMOD_SUBST "De $1q: "
LITERAL_SHOW_SOL_FROM_CONV1 "Solución de $1q hallada mediante el convergente "
LITERAL_SHOW_SOL_FROM_CONV2 " of $1q"
LITERAL_SHOW_FIRST_SOLUTION "Cuando el discriminante vale $1s y $2v = $3s, una solución es ($4s, $5v) = ("
LITERAL_SHOW_SECOND_SOLUTION "La segunda solución es ($1s, $2v) = ("
LITERAL_SHOW_THIRD_SOLUTION "La tercera solución es ($1s, $2v) = ("
LITERAL_PERFORM_TRANSF1 "La transformación "
LITERAL_PERFORM_TRANSF2 " convierte "
LITERAL_PERFORM_TRANSF3 " a "
LITERAL_PERFORM_TRANSF4 "donde: "
LITERAL_PERFORM_TRANSF5 "No hay soluciones porque mcd($1v, $2v, $3v) es mayor que 1."
LITERAL_CBACK_ELLIPTIC1 "Para obtener las soluciones a la ecuación $1q debemos calcular los convergentes de la fracción continua de "
LITERAL_CBACK_ELLIPTIC2 "La fracción continua es: "
LITERAL_CBACK_ELLIPTIC3 "No hay convergentes para los cuales se cumpla $1q."
LITERAL_SOL_SQUARE_DISCR1 "El sistema de dos ecuaciones no tiene soluciones $1v, $2v enteras."
LITERAL_PERFECT_SQUARE_DISCR1 "Multiplicando por 4&#8290;$1v:"
LITERAL_PERFECT_SQUARE_DISCR2 "El término derecho no es múltiplo del número que está a la izquierda del paréntesis, por lo que no hay soluciones."
LITERAL_PERFECT_SQUARE_DISCR3 "Para que el producto valga cero, cualquiera de los paréntesis vale cero."
LITERAL_PERFECT_SQUARE_DISCR4 "Esta ecuación no tiene soluciones enteras."
LITERAL_PERFECT_SQUARE_DISCR5 "Tenemos que hallar todos los factores del término derecho."
LITERAL_CONTFRAC1 "El desarrollo en fracciones continuas de $1s es:"
LITERAL_SHOW_ALL_REC_SOLS1 "donde:"
LITERAL_SHOW_ALL_REC_SOLS2 "y también:"
LITERAL_RECURSIVE_SOLS1 "Soluciones recursivas:"
LITERAL_RECURSIVE_SOLS2 "Coeficientes demasiado grandes."
LITERAL_CBACK_HYPERB1 "No hay soluciones de $1q usando la fracción continua de $2s porque "
LITERAL_CBACK_HYPERB2 " no es múltiplo de "
LITERAL_CBACK_HYPERB3 "Solución con demasiados dígitos."
LITERAL_SOLVE_QUAD1 "El término independiente no es múltiplo de $1b, que es el máximo común divisor de los otros coeficientes, así que no hay soluciones."
LITERAL_SOLVE_QUAD2 "No hay soluciones."
LITERAL_SOLVE_QUAD3 "El discriminante es"
LITERAL_SOLVE_QUAD4 "Aplicamos la transformación de Legendre "
LITERAL_SOLVE_QUAD5 "y obtenemos:"
LITERAL_SOLVE_QUAD6 "donde el término derecho es igual a "
LITERAL_SOLVE_QUAD7 "Dividiendo ambos miembros por "
LITERAL_SOLVE_QUAD8 "El término derecho no es múltiplo de $1b, que es el máximo común divisor de los tres coeficientes, así que no hay soluciones"
LITERAL_SOLVE_QUAD9 "El algoritmo requiere que el término independiente no sea negativo, así que multiplicamos ambos miembros por &minus;1."
LITERAL_QUAD1 "Coeficiente $1v: "
LITERAL_QUAD2 "La ecuación no tiene soluciones enteras."

quadmod
LITERAL_ERROR_QUADMOD "No debe ser negativo"
LITERAL_QUADMOD1 "Coeficiente cuadrático: "
LITERAL_QUADMOD2 "Coeficiente lineal: "
LITERAL_QUADMOD3 "Término independiente: "
LITERAL_QUADMOD4 "Módulo: "
LITERAL_QUADMOD5 "No hay soluciones."

quadraticeq
LITERAL_STEPS_QUADR1 "Para eliminar el término lineal se debe hacer la sustitución:"
LITERAL_STEPS_QUADR2 "El valor indicado en la sustitución es la mitad del coeficiente lineal."
LITERAL_STEPS_QUADR3 "Distribuyendo:"
LITERAL_STEPS_QUADR4 "Simplificando:"
LITERAL_QUADRATIC_EQ1 "Dividiendo la ecuación por el coeficiente cuadrático:"

quartics
LITERAL_STEPS_BIQUADR1 "Como "
LITERAL_STEPS_BIQUADR2 "obtenemos: "
LITERAL_STEPS_COMPLEX_SQROOT1 "Sea "
LITERAL_STEPS_COMPLEX_SQROOT2 "Entonces "
LITERAL_STEPS_COMPLEX_SQROOT3 "Igualando las partes reales de $1q y $2q:"
LITERAL_STEPS_COMPLEX_SQROOT4 "Multiplicando por "
LITERAL_STEPS_COMPLEX_SQROOT5 "Igualando las partes imaginarias de $1q y $2q y dividiendo por 2:"
LITERAL_STEPS_COMPLEX_SQROOT6 "De $1q y $2q:"
LITERAL_STEPS_COMPLEX_SQROOT7 "Usaremos el signo más para que el argumento de la raíz cuadrada sea positiva."
LITERAL_STEPS_COMPLEX_SQROOT8 "De $1q:"
LITERAL_STEPS_COMPLEX_SQROOT9 " es la parte real de "
LITERAL_STEPS_COMPLEX_SQROOT10 " y "
LITERAL_STEPS_COMPLEX_SQROOT11 " es la parte imaginaria de "
LITERAL_STEPS_COMPLEX_SQROOT12 ", obtenemos:"
LITERAL_BIQUADR_EQ1 "Como los coeficientes cubico y lineal valen cero, esta es una ecuación bicuadrática."
LITERAL_BIQUADR_EQ2 "Usando la identidad:"
LITERAL_BIQUADR_EQ3 "obtenemos:"
LITERAL_BIQUADR_EQ4 "Debemos calcular la raíz cuadrada de un número complejo."
LITERAL_BIQUADR_EQ5 "De $1q, $2v y $3v tienen $4?1?el mismo signo??$4?0?distinto signo??".
LITERAL_FERRARI_RAT_ROOT1 "Esta ecuación tiene una raíz racional:"
LITERAL_FERRARI_RAT_ROOT2 "Sustituyendo esta raíz en $1q:"
LITERAL_FERRARI_RAT_ROOT3 "Usando el signo más:"
LITERAL_FERRARI_RAT_ROOT4 "Usando el signo menos en $1q:"
LITERAL_SHOW_DEPR_QUARTIC1 "Dividiendo la ecuación por el coeficiente cuártico:"
LITERAL_SHOW_DEPR_QUARTIC2 "Para eliminar el término cúbico se debe hacer la sustitución:"
LITERAL_SHOW_DEPR_QUARTIC3 "El valor indicado en la sustitución es la cuarta parte del coeficiente cúbico."
LITERAL_SHOW_DEPR_QUARTIC4 "Distribuyendo:"
LITERAL_SHOW_DEPR_QUARTIC5 "Simplificando:"
LITERAL_SHOW_FERRARI_METHOD1 "Usaremos el método de Lodovico Ferrari para resolver la ecuación de cuarto grado usando una ecuación auxiliar (llamada resolvente) de tercer grado."
LITERAL_SHOW_FERRARI_METHOD2 "En el miembro derecho de la siguiente identidad se encuentran los dos primeros términos de la ecuación anterior:"
LITERAL_SHOW_FERRARI_METHOD3 "Como la ecuación vale cero, podemos restar al miembro derecho de la identidad el miembro izquierdo de la ecuación."
LITERAL_SHOW_FERRARI_METHOD4 "Elegimos el valor de $1v tal que el miembro derecho sea un cuadrado perfecto."
LITERAL_SHOW_FERRARI_METHOD5 "De la identidad"
LITERAL_SHOW_FERRARI_METHOD6 "Para que el miembro derecho sea un cuadrado perfecto, podemos hacer que lo que se encuentra fuera del paréntesis valga cero. De esta manera obtenemos una ecuación de tercer grado:"

quintics
LITERAL_QUINTIC_EQ "La ecuación quíntica no se puede expresar mediante radicandos."

rootseq
LITERAL_SHOW_X "$1s a $2s = "
LITERAL_SHOW_DEGREES " y "
LITERAL_SYMM_OR_ALTER1 "Las raíces del polinomio $1?1+?número $1d ??se pueden expresar mediante expresiones radicales."
LITERAL_SYMM_OR_ALTER2 "We set $1v = "
LITERAL_SYMM_OR_ALTER3 "El grado del polinomio es $1d que es menor que 5."
LITERAL_SYMM_OR_ALTER4 "primo mayor que la mitad del grado del polinomio"
LITERAL_SYMM_OR_ALTER5 " y menor que el grado menos 2"
LITERAL_SYMM_OR_ALTER6 "primo mayor que la tercera parte del grado del polinomio"
LITERAL_SYMM_OR_ALTER7 " y éste ($1d) es impar)"
LITERAL_SYMM_OR_ALTER8 "impar mayor que la mitad del grado del polinomio"
LITERAL_SYMM_OR_ALTER9 "longitud 2)"
LITERAL_SYMM_OR_ALTER10 "longitud 3)"
LITERAL_SHOW_NO_SOLVABLE1 "Las raíces del polinomio $1?1+?número $1d ??no se pueden expresar mediante expresiones radicales."
LITERAL_SHOW_NO_SOLVABLE2 " Los grados de los factores del polinomio módulo $1d son "
LITERAL_SHOW_NO_SOLVABLE3 " y los grados de los factores del polinomio módulo $1d son "
LITERAL_SHOW_NO_SOLVABLE4 " (el grupo de Galois contiene un ciclo de "
LITERAL_SINE "seno de"
LITERAL_COSINE "coseno de"
LITERAL_ARC_COSINE "arco coseno de"
LITERAL_TIMES_PI "por pi"
LITERAL_GET_ROOTS_POLY1 "La ecuación a resolver es:"
LITERAL_GET_ROOTS_POLY2 "No puedo determinar si las raíces del polinomio $1?1+?número $1d ??se pueden resolver mediante expresiones radicales o no."

showtime
LITERAL_SHOW_TIME_ELAPSED "Tiempo transcurrido: "

siqs
LITERAL_INIT_SIQS_STRINGS1 "Parámetros de SIQS: $1d primos, límite de la criba: $2d"
LITERAL_INIT_SIQS_STRINGS2 "Buscando el mejor multiplicador de Knuth-Schroeppel..."
LITERAL_GET_MULT_AND_FB "Multiplicador: $1d, base de factores: $2d"
LITERAL_SHOW_SIQS_INFO1 "$1d congruencias halladas ($2d%) con $3d primos diferentes."
LITERAL_SHOW_SIQS_INFO2 "Relaciones: $1d completas y $2d obtenidas de $3d parciales."
LITERAL_SHOW_SIQS_INFO3 " Fin de la criba en "

siqsLA
LITERAL_SHOW_MATRIX_SIZE1 "Resolviendo la matriz de congruencias de $1d &times; $2d usando el algoritmo de Lanczos en bloques."
LITERAL_BLOCK_LANCZOS1 "Progreso del álgebra lineal: $1d%"

sumSquares
LITERAL_SHOW_SUM_SQB "Todas las sumas de dos cuadrados"
LITERAL_SHOW_SUM_TWO_SQ1 "Suma de dos cuadrados:"
LITERAL_SHOW_SUM_TWO_SQ2 "Más sumas de dos cuadrados"

tsqcubes
LITERAL_BATCH_SQCUBE_CBACK "¡Error interno! Por favor envíe este número al autor de la calculadora."

tsquares
LITERAL_SHOW_STATUS1 "Transcurrió "
LITERAL_SHOW_STATUS2 "&nbsp;&nbsp;&nbsp;Intentando obtener suma de dos cuadrados. Prueba número $1d"